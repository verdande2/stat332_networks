---
title: "STAT332 Statistical Analysis of Networks Sec 01 - Homework 2 - Prof. Joe Reid"
author: "Andrew Sparkes"
date: "`r Sys.Date()`"
output:
  html_document:
    self_contained: true
    df_print: paged
  word_document: default
  pdf_document: default
due: "23-01-2026"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) # default to echo all the things

library(readr)
library(igraph)
library(tidyverse)
library(RColorBrewer)
library(scales)
library(data.table)
library(gt)
library(testit)
```

```{r user_configurable_settings}
node_filename <- "node_list.csv"
edge_filename <- "edge_list.csv"
```

To produce the CSV edge and node list files, please run `rmarkdown::render("make_graph_csvs.Rmd")` and they'll be created in the current working directory!

```{r utility_functions}
# various utility functions, will inevitably put these in a utils.R library at some point
fruit_or_veg <- function(thing) {
  switch(thing,
    Apple = "Fruit",
    Banana = "Fruit",
    Carrot = "Vegetable",
    Date = "Fruit",
    Eggplant = "Fruit",
    Fig = "Fruit",
    Grapes = "Fruit",
    Horseradish = "Vegetable",
    "Unknown Frui-egetable!" # default case
  )
}

# after taking the time to make a pretty switch call in the previous function, it appears I don't need to classify, just test if fruit is true or false with a whitelist. Oh well, another quick utility function
is_fruit <- function(thing) {
  thing %in% c("Apple", "Banana", "Date", "Eggplant", "Fig", "Grapes")
}

print_big_fancy_summary_table <- function(graph) {
  big_fancy_igraph_table <- data.table(
    Label = c(
      "Connected?",
      "Simple?",
      "Loops?",
      "Multigraph?",
      "Weighted?",
      "Directed?",
      "Acyclic?",
      "Bipartite?",
      "Tree?",
      "Forest?",
      "Size:",
      "Components:",
      "Isolate Proportion:",
      "Density:",
      "Diameter:",
      "Average Path Length:"
    ),
    Value = c(
      is_connected(graph),
      is_simple(graph),
      any_loop(graph),
      any_multiple(graph),
      is_weighted(graph),
      is_directed(graph),
      is_acyclic(graph),
      is_bipartite(graph),
      is_tree(graph),
      is_forest(graph),
      gorder(graph),
      count_components(graph),
      sum(degree(graph) == 0) / gorder(graph),
      edge_density(simplify(graph)),
      diameter(graph),
      mean_distance(graph)
    )
  )
  big_fancy_igraph_table |> 
    gt()
}

# this was actually quite handy as an utility func
print_igraph_attr <- function(graph) {
  print("--- Graph Attributes ------")
  print(graph_attr(graph))

  print("--- Vertex Attributes ------")
  print(vertex_attr(graph))

  print("--- Edge Attributes ------")
  print(edge_attr(graph))
}

# generic version of this function, without the third col of expected values
# editor's note: splitting table into two subtables, first for T/F values and the second for the component counts
print_metadata_summary_TF_table <- function(graph) {
  tbl_TF <- data.table(
    Label <- c(
      "Directed?",
      "Weighted?",
      "Not Simple?",
      "Has Multiple Edges?",
      "Weakly Connected?",
      "Strongly Connected?"
    ),
    Value <- c(
      igraph::is_directed(g),
      igraph::is_weighted(g),
      !igraph::is_simple(g),
      length(E(g)) > 1,
      is_connected(g, mode = "weak"), # mode = weak is the default
      is_connected(g, mode = "strong")
    )
  )
  colnames(tbl_TF) <- c("Label", "Value")
  tbl_TF |> 
    gt() |> 
    fmt_tf(columns = where(~ is.numeric(.x)), tf_style = "true-false")
}

print_metadata_summary_components_table <- function(g) {
  tbl_components <- data.table(
    Label <- c(
      "# of Strongly-connected components:",
      "# of Weakly-connected components:"
    ),
    Value <- c(
      components(g, mode = "strong")$no,
      components(g, mode = "weak")$no # mode = weak is the default
    )
  )
  colnames(tbl_components) <- c("Label", "Value")
  tbl_components |> 
    gt() |> 
    fmt_number(columns = where(~ is.numeric(.x)), decimals = 0, use_seps = TRUE)
}
```

# Instructions:

Please complete this homework assignment by the due data posted on canvas. Please submit your work in an html file with solutions and code presented completely.

# Homework 2: Networks and visualization with igraph

## Question 1:

Create a .csv file using a spreadsheet software or notepad. This file should have **four** columns: from, to, weight, name. Create a network using an edge-list with **two** **strongly connected** components where the whole network is **weakly connected**. The network will have nodes called Apple, Banana, Carrot, Date, Eggplant, Fig, Grapes, and Horseradish (I'll just use letters for the rest of the instructions. A, B, C, D, and E are **strongly connected**, as are F, G, and H. Furthermore, the graph should be a **multigraph** where there are **two** paths from A to B and **three** paths from E to D. Generate a **weights** attribute by creating **random weights** between 0 and 1 for each of the edges. Finally, provide a **names** attribute for every edge denoting the edge: S1 if it's the first edge connecting two nodes, S2 if it's the second, and S3 if it's the third. The graph should have **no isolates**. Also, create a nodes file that has the names of the nodes in a column called **name** and a column called **type** that has values of Fruit and Vegetable depending on the observation.

### 1.a) 

Read in your edge list. The following code can help.

```{r load_the_edge_list}
edges <- readr::read_csv(edge_filename)

# prune out the edge start and end vertices and attrs and dump them in edge_list
edge_list <- edges[, c("from", "to", "name", "weight")]
```

Once you have your edge list, convert it to an `igraph` object using the `graph_from_data_frame()` function (you may need the documentation).

```{r convert_df_to_igraph}
# g is not very descriptive, but it'll save some keystrokes...
g <- igraph::graph_from_data_frame(d = edge_list)
```

### 1.b)

Produce a summary of your graph to make sure the `igraph` works correctly.

```{r assert_igraph_class}
testit::assert(paste0("ig object should be of class: igraph, but returned class: ", class(g)), {
  class(g) == "igraph"
})
```

```{r print_ig_details}
print("Printing information about graph:")
g # default print output is actually preferable to summary(g)... interesting.
print_igraph_attr(g)
```

---

### 1.c)

In Lab 2 we looked at how to create a summary of the metadata for the graph. Use this code as a basis to make sure that the above conditions are met in general (Directed, Weighted, Not Simple, Has Multiple Edges, is weakly connected but not strongly connected, has two components when counting the number of strongly connected components but only one when counting the number of weakly connected components.

```{r summary_with_compare}
# editor's note: splitting table into two subtables, first for T/F values and the second for the component counts
print_metadata_summary_TF_w_compare <- function(g) {
  tbl_TF <- data.table(
    Label <- c(
      "Directed?",
      "Weighted?",
      "Not Simple?",
      "Has Multiple Edges?",
      "Weakly Connected?",
      "Strongly Connected?"
    ),
    Value <- c(
      igraph::is_directed(g),
      igraph::is_weighted(g),
      !igraph::is_simple(g),
      length(E(g)) > 1,
      is_connected(g, mode = "weak"), # mode = weak is the default
      is_connected(g, mode = "strong")
    ),
    Expected <- c(
      TRUE, # Directed
      TRUE, # Weighted
      TRUE, # Not Simple
      TRUE, # Has Multiple Edges
      TRUE, # Weakly Connected
      FALSE # Strongly Connected
    )
  )
  colnames(tbl_TF) <- c("Label", "Value", "Expected")
  tbl_TF |> 
    gt() |> 
    fmt_tf(columns = where(~ is.numeric(.x)), tf_style = "true-false")
}
  
print_metadata_summary_components_w_compare <- function(g) {
  tbl_components <- data.table(
    Label <- c(
      "# of Strongly-connected components:",
      "# of Weakly-connected components:"
    ),
    Value <- c(
      components(g, mode = "strong")$no,
      components(g, mode = "weak")$no # mode = weak is the default
    ),
    Expected <- c(
      2, # Strongly-Connected Components
      1 # Weakly-Connected Components
    )
  )
  colnames(tbl_components) <- c("Label", "Value", "Expected")
  tbl_components |> 
    gt() |> 
    fmt_number(columns = where(~ is.numeric(.x)), decimals = 0, use_seps = TRUE)
}

print_metadata_summary_TF_w_compare(g)
print_metadata_summary_components_w_compare(g)
# TODO need moar asssert()s
```

---

```{r set_weighted_and_directed_attrs}
g <- set_graph_attr(g, name = "Weighted", value = TRUE)
g <- set_graph_attr(g, name = "Directed", value = TRUE)
```

Wait a minute. If you used the same work we did in lab, you will find out that this graph is NOT WEIGHTED! That can't be right. Well, I suppose it can because we don't have the right edge properties on this graph.

### 1.d)

I guess we better add the other elements from the edges matrix into our graph as edge attributes.

```{r look_at_existing_attributes}
# first, let's remind ourselves what attributes are already present in the graph
print_igraph_attr(g)
```

Well, when we read the graph in as a data frame and then used `igraph::graph_from_data_frame()`, we already added those edge attributes, so we are golden!

Also, read in your nodes file the same way you did for the edges file and update the vertex property with the types.

```{r load_dem_nodes}
# read in your nodes file
node_list <- readr::read_csv(node_filename)
node_type_list <- node_list[, c("type")]
```

Now, we have the nodes list csv file loaded, and have pulled out the columns for name and type for later use.

```{r update_vertex_attributes}
# update the vertex property with the types
V(g)$type <- unlist(node_type_list)
```

Let's verify we see vertex name and vertex type in our `igraph`:

```{r verify_vertex_attributes}
print_igraph_attr(g)
```

---

Finally, produce a summary of the graph again. You should see that, because you have a column called weight, the summary is now: `DNWB 8`. This means it is a weighted graph.


```{r print_metadata_for_graph_after_attrs}
g
print_igraph_attr(g)
```

`IGRAPH a82ac7f DNWB 8 31 --`! Check! Got that `W`! That looks good to me!

### 1.e)

Produce a quick plot of the graph to make sure it looks like you expected.

```{r ugly_plot}
# quick, dirty, ugly plot
plot(g)
```

### 2.)  Graphing

Now, we are going to work on improving the plot, but we actually have a problem. The vertex name of `type` is actually a reserved term. This one is supposed to be a logical of `1` or `0`. We need to rename our vertex attribute of `type` to `classification` and then overwrite the `type` variable. I'll give you this code.

```{r rename_type_to_classification}
V(g)$classification <- V(g)$type
```

Of note, the edge attribute `type` still exists at this point, to be overwritten in the next code block:

```{r assign_type_based_on_fruit}
# so if it's a fruit type, it gets a TRUE, else FALSE
V(g)$type <- ifelse(V(g)$classification == "Fruit", TRUE, FALSE) # so type isn't /really/ a "type" anyone, it's an is_fruit bool flag... Got it.
```

Now, start by using the `layout_as_bipartite` in your plot.

```{r setup_bipartite_graph_layout}
layout <- igraph::layout_as_bipartite(
  graph = g,
  types = NULL, # NULL => will read vertex.type as type
  hgap = 5,
  vgap = 5,
  maxiter = 1000
)
```

You should see a two row format for the results. Now, we need to make this look better.

### 1.e)  

Your final task on this will be to make this look better based on the lab from class. Create colors, use transparency, label edges, change shapes and thicknesses, etc... The one requirement is that you calculate the in-degree of the nodes, store this as a vertex attribute, and use that to size the vertex. Add a title, subtitle, and caption to the graph, and make sure to use legends.

```{r setup_bipartite_graph_plot_params}
par(mar = c(3, 1, 4, 1)) # margins
```

```{r plot_the_bipartite_graph}
plot(
  x = g,
  layout = layout,
  vertex.sizes = 10,
  vertex.color = adjustcolor(brewer.pal(length(V(g)), "Paired"), alpha.f = 0.5),
  vertex.shape = "circle",
  vertex.label = V(g)$fullname,
  vertex.label.cex = 1,
  vertex.label.dist = 0.5, # ctr

  edge.widths = 5 * E(g)$weight, # 5 * [0,1]
  edge.color = "black",
  edge.lty = 1, # solid lines
  edge.curved = 0.35, # mild curve

  edge.label = round(E(g)$weight, 4), # edges have weights labeled (and rounded)
  edge.label.cex = 0.6,
  edge.arrow.mode = 1 # normal arrows
)

# omitting legend, as this is just a set of letters and random decimals, with fruit/vegetable strings attached to the vertices

title_text <- "Bipartite Graph"
mtext(side = 3, line = 0, at = 0, adj = 0.5, cex = 1, title_text) # 3 = top, adj = 0.5 is centered
```

Well, it's a bit ugly still, but we'll try to improve that by adding color and adjusting some parameters...

```{r make_it_colorful_and_stuff, fig.dim=c(8,5)}
# calculate the in-degree of the nodes, store this as a vertex attribute for later vertex sizing
# g <- set_vertex_attr(g, name = "degree_in", value = strength(g, mode = "in"))
g <- set_vertex_attr(g, name = "degree_in", value = degree(g, mode = "in")) # switched to using degree() over strength(), because multiplying by the random weights (in [0,1]) yields bleh decimals to use for scaling below

plot.new() # clear the canvas

plot(
  x = g,
  layout = layout,

  # use the indegree of the node to size the vertex
  vertex.size = scales::rescale(V(g)$degree_in, c(10, 50)), # rescale vertices by their in-degree between 10 and 50px radius
  vertex.color = adjustcolor(brewer.pal(length(V(g)), "Paired"), alpha.f = 0.5), # semi-transparent, from Paired palette
  vertex.shape = "circle", # changed shapes

  vertex.label = V(g)$fullname,
  vertex.label.cex = scales::rescale(V(g)$degree_in, c(1, 3)), # scale the vertex label as well, from 1.0 to 3.0 based on in-degree
  vertex.label.dist = 0.5, # ctr
  vertex.label.color = "black", # change vertex label color, no transparency

  edge.width = 3 * E(g)$weight, # 3 * [0,1] # change thicknesses
  edge.color = "blue", # change edge color
  edge.lty = 1, # solid lines
  edge.curved = 0.35, # mild curve

  edge.label = round(E(g)$weight, 4), # edges have weights labeled (and rounded)
  edge.label.color = "red", # change edge label color

  edge.arrow.mode = 1, # normal arrows
  edge.arrow.size = 0.5
)

# Add a title
title_text <- "Bipartite Graph"
mtext(side = 3, line = 2, at = 0, adj = 0.5, cex = 1, title_text) # 3 = top, adj = 0.5 is centered

# subtitle
subtitle <- "Nodes A-H represent fruits and vegetables. The weighted edges represent ???."
mtext(side = 3, line = 1, at = 0, adj = 0.5, cex = 0.7, subtitle)

# caption
caption <- paste0("Graph data from ", edge_filename, " and ", node_filename)
mtext(side = 1, line = 2, at = 1, adj = 0, cex = 0.5, caption)

# legends
# reference: https://stackoverflow.com/questions/38451431/add-legend-in-igraph-to-annotate-difference-vertices-size

# first take:
# takes the quantiles (min, 25%, 50%, 75%, max)x(degree_in of vertices)
# => strips names => round to int => remove duplicates
legend_labels <- unique(round(unname(quantile(V(g)$degree_in)), 0)) # round each quantile to nearest int, at max 5 legend entries

# Well, that technically works, but is... not very nice looking and doesn't feel very R-ish, let's refactor with the glorious pipe!

legend_labels <- V(g)$degree_in |> # gather all the vertices' degree in attributes
  quantile() |> # produces 5-length vector of (min, 25% quantile, 50% quantile, 75% quantile, and max for passed in data)
  round(digits = 0) |> # round to integer
  unique() # prune any duplicates due to rounding to same integer

# I must say, utilizing the pipe sure does make that flow look more easily understandable and clear. Pretty nifty! Learning happened here today. I like this.

legend(
  "topright",
  title = "Vertex In-degree",
  legend = paste0(legend_labels, " nodes"),
  bty = "n", # n = no border # couldn't figure out how to increase padding between border rect and legend items, so screw the border
  pch = 21, # circle
  pt.bg = "purple", # purple is best color
  pt.cex = legend_labels, # scale the pts directly from the label values
  x.intersp = 2, # double space widths
  y.intersp = 2, # double space heights
  inset = 0.0, # percentage
  cex = 1 # general scaling factor
)
```

That'll do pig, that'll do...

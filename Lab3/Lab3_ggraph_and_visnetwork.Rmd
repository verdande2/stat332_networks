---
title: "STAT332 Statistical Analysis of Networks Sec 01 - Lab 3 - Prof. Joe Reid"
author: "Andrew Sparkes"
date: "`r Sys.Date()`"
due: "30-01-2026"
output:
  html_document:
    self_contained: true
    df_print: paged
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(knitr)
library(gt) # for fancy tables
library(data.table) # data tables
library(igraph) # Our standard graph object.
library(readr) # Reading in the data
library(ggraph) # Plotting
library(tidygraph) # Managing our graph object
library(RColorBrewer) # Getting Colors
library(scales) # scaling factors
library(grid) # for unit()
library(ggrepel) # for stronger label repel
library(visNetwork) # for network graphs
library(ggplot2) # for ploots
```

```{r user_configurable_settings}
# for first part:
media_network_filename <- "Media Network.rds"

# for later part:
actor_roles_filename <- "Actor Roles.csv"
table_2_filename <- "2006 Koschade Table 2.csv"

SKIP_AHEAD <- TRUE # bool flag to comment out part 1 and 2, set to FALSE to output parts 1 and 2
```

```{r extra_functions}
print_igraph_attr <- function(graph) {
  print("--- Graph Attributes ------")
  print(graph_attr(graph))

  print("--- Vertex Attributes ------")
  print(vertex_attr(graph))

  print("--- Edge Attributes ------")
  print(edge_attr(graph))
}
```

`r if(SKIP_AHEAD) {"Commenting out first introductory sections to skip to the relevant bits!\\n\\n... snip ...\\n\\begin{comment}"}`

## 1.) Setup

Welcome to Lab 3. This week we are going to be working with alternatives to `igraph`. This means that we want to get familiar with the tools from `ggraph` (<https://ggraph.data-imaginist.com/index.html>) and `visNetwork` (<https://datastorm-open.github.io/visNetwork/>).

We're going to be using the same data as lab 2 and trying to reproduce the same graph as last time, so lets get started.

## 2.) Lab Walkthrough

### 2.a) Getting started.

Using `ctrl-alt-i` you can create a section where you are going to embed R code. We're going to start by loading the raw data file:

```{r read_data_file}
g <- read_rds(media_network_filename)
```

Just to remind ourselves of what we're working with, let's make sure we print out our vertex and edge attributes:

```{r graph_summary}
g
print_igraph_attr(g)
```

### 2b.) Adding degree strength as attributes

Just like last week, we want to add a few more attributes.

```{r set_vertex_strength_attrs}
g <- set_vertex_attr(g, name = "strength_in", value = strength(g, mode = "in"))
g <- set_vertex_attr(g, name = "strength_out", value = strength(g, mode = "out"))
g <- set_vertex_attr(g, name = "strength_total", value = strength(g, mode = "total"))
```

Let's make sure we have our new attributes.

```{r summarize_again}
summary(g)
```

### 2d.) Let's graph

This time, we're going to use

```{r plot_the_graph}
g |> # Start with the graph object
  ggraph(layout = "lgl") + # initializes the plot
  geom_node_point() + # adds the nodes to the plot
  geom_edge_link() # adds the edges to the plot
```

Alright, that's the basics.

```{r make_more_graph}
# For reference:
# IGRAPH 52040ab DNW- 17 49 --
# + attr: name (v/c), media (v/c), media.type (v/n), type.label (v/c), audience.size (v/n), strength_in (v/n),
# | strength_out (v/n), strength_total (v/n), type (e/c), weight (e/n)

p <- g |> # Start with the graph object
  ggraph(layout = "lgl") +
  geom_node_point(
    aes(
      size = audience.size,
      fill = type.label,
      shape = type.label
      ),
    color = "grey30",
    alpha = 0.5,
    stroke = 0.4
  ) +
  geom_node_text(
    aes(label = media),
    repel = TRUE,
    size = 3
  ) +
  geom_edge_link(
    aes(
      color = type,
      # linetype = type, # original line (pisses it off good!)
      # edge_linetype = type, # attempt at correction (also pisses it off) see note below
      width = weight
      ),
    alpha = 0.5,
    lineend = "round",
    arrow = arrow(type = "closed"),
    end_cap = circle()
  ) +
  # the above linetype params both yield:
  #   Error in `as_discrete_pal()`:
  # ! Cannot convert `x` to a discrete palette. # TODO look into this behavior

  labs(
    title    = "Media Networks Link to and Reference Each Other",
    subtitle = "A network plot of networks.",
    caption  = "Data from: https://kateto.net/network-visualization."
  )

p
```

Okay, it's not perfect. We can do better, but the format is just so much better. Let's fix the scales next:

```{r fixing_scales}
# Shape mapping (3 shapes)
node_types <- sort(unique(V(g)$type.label))
shape_vals <- c(21, 22, 24)[seq_along(node_types)]
shape_map <- setNames(shape_vals, node_types)

p <- ggraph(g, layout = "lgl") +
  geom_node_point(
    aes(
      size = audience.size,
      fill = type.label,
      shape = type.label
      ),
    alpha = 0.6
  ) +
  geom_node_text(
    aes(
      label = media
      ),
    repel = TRUE,
    size = 3
  ) +

  geom_edge_arc(
    aes(
      color = type,
      # linetype = type, # this line /also/ triggers the noted error below! Argh!
      width = weight
      ),
    alpha = 0.4,
    lineend = "round",
    arrow = arrow(length = unit(3, "mm"), type = "closed"),
    end_cap = circle(2, "mm"),
    strength = 0.3
  ) +


  scale_size_continuous(name = "Audience Size", range = c(1, 8)) +
  scale_shape_manual(values = shape_map, guide = "none") +
  scale_edge_width(range = c(0.5, 1.5), guide = "none") +
  # scale_edge_linetype(guide = "none") + # this line triggers the below error! see note at end of chunk! # TODO look into this

  guides(
    size = guide_legend(nrow = 2, byrow = TRUE),
    fill = guide_legend(
      nrow = 1, byrow = TRUE, title = "Vertex Color/Shape",
      override.aes = list(shape = shape_vals)
    ),
    edge_color = guide_legend(
      ncol = 2, byrow = TRUE,
      title = "Reference Type"
    )
  ) +

  labs(
    title    = "Media Networks Link to and Reference Each Other",
    subtitle = "A network plot of networks.",
    caption  = "Data from: https://kateto.net/network-visualization."
  )

p
# This code chunk barfs out:
# > rlang::last_trace(drop = FALSE)
# <error/rlang_error>
# Error in `as_discrete_pal()`:
# ! Cannot convert `x` to a discrete palette.
# ---
# Backtrace:
#      ▆
#   1. ├─base (local) `<fn>`(x)
#   2. └─ggplot2 (local) `print.ggplot2::ggplot`(x)
#   3.   ├─ggplot2::ggplot_build(x)
#   4.   ├─ggraph:::ggplot_build.ggraph(x)
#   5.   ├─base::NextMethod()
#   6.   └─ggplot2 (local) `ggplot_build.ggplot2::ggplot`(x)
#   7.     └─npscales$set_palettes(plot@theme)
#   8.       └─ggplot2 (local) set_palettes(..., self = self)
#   9.         ├─scales::as_discrete_pal(elem)
#  10.         └─scales:::as_discrete_pal.default(elem)
#  11.           └─cli::cli_abort("Cannot convert {.arg x} to a discrete palette.")
#  12.             └─rlang::abort(...)
# this stack trace is ... less than useful... All I know about this error is that trying to map to edge linetype leads to some function getting a param `x` passed that is not a discrete palette already. I'd imagine it's probably a /continuous/ palette, but unsure where the conversion needs to happen # TODO
```

If you're paying attention, you might notice that I stored the graph as the variable `p` and then called it by just using `p` at the end of the code cell. I did this for a reason. In `ggplot2`, we can theme our graphs. <https://ggplot2.tidyverse.org/reference/theme.html>

```{r adding_theme}
p + theme(
  plot.title = element_text(face = "bold", size = 14),
  legend.box.background = element_rect(color = "black", size = 0.5),
  legend.box.margin = margin(1, 1, 1, 1),
)
```

`r if(SKIP_AHEAD) {"\\end{comment}"}`

**Note**: Before I forget, I had to modify a couple of the chunks above, commenting out a few parameters related to edge line type. I'll have to look into what is the source of that issue.

## 3.) Your turn:

In the data for this lab, there are two files (and a paper describing where they came from). The "Actor Roles" file provides the list of nodes and their corresponding attributes. The "Table 2" file provides a matrix of associations and their strengths that you can read in as a matrix and extract the edge list from. Please create a graph which uses shapes, colors, and edge-widths to represent this network. Also, please make sure to use both color and type on edges to denote any edge relationships between Command Team members and any other members in the network. Use `ggraph` to produce this plot. Be certain to add titles, subtitles, and footnotes/captions as appropriate and include a corresponding legend.

```{r read_in_data_files}
actor_roles <- readr::read_csv(actor_roles_filename, col_names = TRUE, progress = TRUE)
table_2 <- readr::read_csv(table_2_filename, col_names = TRUE, progress = TRUE)
```

```{r convert_to_igraphs}
# actor_roles appears to map each actor to a number of roles, both strings
# table 2 seems to represent an adjacency matrix, with weights
# will need to merge data from both into graph obj

df <- as.data.frame(table_2) # first, convert to df
rownames(df) <- df$...1 # name the rows = the first col (...1) which are the terrorist names
df <- df |> select(-...1) # select all cols BUT that first col (...1)
adj_matrix <- as.matrix(df) # convert to matrix so igraph won't complain

# finally, make the igraph obj
g_actors <- igraph::graph_from_adjacency_matrix(adj_matrix, mode = "directed", weighted = TRUE, diag = FALSE)

# utilizing the data from the actors/role csv, assign the roles to each vertex as an attr
g_actors <- set_vertex_attr(g_actors, name = "Role", value = actor_roles$Role) # TODO double check these are assigned in the proper order

g_actors
print_igraph_attr(g_actors)
```
```{r identify_command_team_relations}
command_team_edges <- E(g_actors)[.inc(V(g_actors)[Role == "Command Team"])]

# TODO do something special to command_team_edges...


# note: command team members: id 1 Muklas, 4 Samudra, 6 Idris (should be 62 edges)
command_team_edges
```

```{r setup_the_ploot}

# Shape mapping (3 shapes)
node_types <- sort(unique(V(g)$type.label))
shape_vals <- c(21, 22, 24)[seq_along(node_types)]
shape_map <- setNames(shape_vals, node_types)

# create graph using ggraph
p <- ggraph(g_actors, layout = "lgl") +

  # custom shapes
  # custom colors
  geom_node_point(
    aes(
      size = audience.size,
      fill = type.label,
      shape = type.label,
      color = "blue"
      ),
    alpha = 0.6
  ) +

  geom_node_text(
    aes(
      label = Actor
      ),
    repel = TRUE,
    size = 3
  ) +

  # custom edge widths
  # custom edge colors? maybe skip in favor of highlighting Command Team
  # use custom color AND type on edges to denote Command Team members
  geom_edge_arc(
    aes(
      color = "black", #ifelse(Role == "Command Team", "red", "black"), # denote command team
      # linetype = type, # this line /also/ triggers the noted error below! Argh!
      width = weight
      ),
    alpha = 0.4,
    lineend = "round",
    arrow = arrow(length = unit(3, "mm"), type = "closed"),
    end_cap = circle(2, "mm"),
    strength = 0.3
  ) +

  scale_size_continuous(name = "Audience Size", range = c(1, 8)) +
  scale_shape_manual(values = shape_map, guide = "none") +
  scale_edge_width(range = c(0.5, 1.5), guide = "none") +
  # scale_edge_linetype(guide = "none") + # this line triggers the below error! see note at end of chunk!

  # legend
  guides(
    size = guide_legend(nrow = 2, byrow = TRUE),
    fill = guide_legend(
      nrow = 1, byrow = TRUE, title = "Vertex Color/Shape",
      override.aes = list(shape = shape_vals)
    ),
    edge_color = guide_legend(
      ncol = 2, byrow = TRUE,
      title = "Reference Type"
    )
  ) +

  # title
  # subtitle
  # captions
  # footnotes
  labs(
    title    = "Media Networks Link to and Reference Each Other",
    subtitle = "A network plot of networks.",
    caption  = "Data from: https://kateto.net/network-visualization."
  )







p + theme(
  plot.title = element_text(face = "bold", size = 14),
  legend.box.background = element_rect(color = "black", size = 0.5),
  legend.box.margin = margin(1, 1, 1, 1),
)
```

## 4.) `visNetwork`

As opposed to the `ggplot2` framework where most of the plot information is taken care of within the plot code, in `visNetwork`, the work is generally done by taking care of most of the information outside of the plotting code. This is done by creating data frames for the nodes and edges separately and then adding attributes with special names to them. For example, a node or edge attribute of "title" will be the information for the tooltip which pops up on hover-over by the mouse. The "group" is specifically used for the legend.

```{r}
# Build nodes
nodes <- igraph::as_data_frame(g, what = "vertices") |>
  tibble::rownames_to_column("id") |> # this is an important function call, looking ahead to visNetwork's obsession with int ids
  mutate(
    id    = as.character(id),
    label = media,
    value = audience.size,
    group = type.label
  )

# Shape mapping
node_types <- sort(unique(nodes$group))
shape_vals <- c("dot", "square", "triangle")[seq_along(node_types)]
shape_map <- setNames(shape_vals, node_types)
nodes$shape <- shape_map[nodes$group]

# Node colors (background)
node_colors <- setNames(scales::hue_pal()(length(node_types)), node_types)
nodes$color.background <- node_colors[nodes$group]
nodes$color.border <- "#444444"

nodes$title <- paste("Media Name: ", nodes$media, "<br>Media Type: ", nodes$type.label, "<br>Audience Size: ", nodes$audience.size)

# Build edges
edges <- igraph::as_data_frame(g, what = "edges") |>
  mutate(
    from   = as.character(from),
    to     = as.character(to),
    width  = scales::rescale(weight, to = c(0.5, 1.5)),
    arrows = "to",
    smooth = TRUE
  )

# Edge colors
edge_types <- sort(unique(edges$type))
edge_colors <- setNames(scales::hue_pal()(length(edge_types)), edge_types)
edges$color <- edge_colors[edges$type]

# Dash mapping (linetype analogue)
edges$dashes <- edges$type == edge_types[2] # example: second type dashed

edges$title <- paste("Reference Type: ", edges$type)
```

There are disadvantages to storing data this way (for example, what if the title attribute was naturally in the dataset to represent a political title?). But, once the data is in, it becomes very easy to produce a really good plot automatically.

```{r}
vis <- visNetwork(nodes, edges,
  main = "Media Networks Link to and Reference Each Other",
  submain = "A network plot of networks.",
  footer = "Data from: https://kateto.net/network-visualization.",
  width = "100%"
) |>
  visNodes(scaling = list(min = 5, max = 30)) |>
  visEdges(smooth = list(enabled = TRUE, type = "dynamic")) |>
  visOptions(
    highlightNearest = TRUE,
    nodesIdSelection = TRUE,
    collapse = TRUE
  ) |>
  visInteraction(
    dragNodes = TRUE,
    dragView  = TRUE,
    zoomView  = TRUE
  ) |>
  visPhysics(stabilization = TRUE)

vis
```

## 5.)  Your Turn 

Reproduce the same graph as above (or close to it, showing the same information) using visNetwork. Make the tooltip display the individual's name and their role. Don't worry about a legend on this plot.

```{r adjust_the_graph_and_replot}
# we already kinda made this graph in visNetwork, so we just need to make the tooltips happen.

vis

# TODO tooltip w/ individual's name and role

# no legend
```

#### Something to think about.

How centralized is this network? Are there any key players that could be removed to make the network fail in their goals? Centralized networks are highly resilient but also insecure, which can play into strategies when analyzing these networks. We'll talk about a number of measures of network structure next week.

```{r centrality_time}
# TODO centrality measures
```

**Answer:**
TODO me!

## 6.) Results

What you need to do next is to "knit" your document into an html using the "Knit" button near the top of the screen. This will give you an HTML that you can turn in.

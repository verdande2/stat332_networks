---
title: 'STAT332 Statistical Analysis of Networks Sec 01 - Homework 3 - Prof. Joe Reid'
author: "Andrew Sparkes"
date: "`r Sys.Date()`"
due: "30-01-2026"
output:
  html_document:
    self_contained: true
    df_print: paged
  pdf_document: default
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(echo = TRUE)

library(networkdata)
library(ggplot2)
library(tidygraph)
library(igraph)
library(ggraph)
library(visNetwork)
library(tibble)
library(purrr)
library(ragg)
library(extrafont)
loadfonts(device = "win")
```

```{r user_configurable_settings}
gml_filename <- "Homework_3_filtered_data.gml"

SKIP_AHEAD <- TRUE # skips ahead and truncates off the demo code/markdown (uses a TeX comment to omit output)
```


```{r extra_functions}
print_igraph_attr <- function(graph) {
  print("--- Graph Attributes ------")
  print(graph_attr(graph))

  print("--- Vertex Attributes ------")
  print(vertex_attr(graph))

  print("--- Edge Attributes ------")
  print(edge_attr(graph))
}
```

This homework is focused on plotting with `ggraph` and `visNetwork` but will also be used to explore the `tidygraph` framework. `tidygraph` is a library which provides a subclass of `igraph` and enables much smoother manipulation of graph objects using the `tidyverse` methodologies.

## Instructions:

Please complete this homework assignment by the due data posted on canvas. Please submit your work in an html file with solutions and code presented completely.

`r if(SKIP_AHEAD) {"Commenting out middle chunks to skip to the relevant bits!\\n\\n... snip ...\\n\\begin{comment}"}`

First, make sure to install the `networkdata` package. This package isn't located in CRAN so it takes a little bit of work using remotes library to get. If you don't have remotes, install that first. Then, install network data using these instructions: <https://www.rdocumentation.org/packages/networkdata/versions/0.1.6>

# 1.) Getting the Data

```{r reference_code}
# install.packages("drat")
# drat::addRepo("schochastics")
# install.packages("networkdata")

# OR for dev version:
# install.packages("remotes")
# remotes::install_github("schochastics/networkdata")

# installing the dev version for now
```

```{r}
?wta
```

We are going to use the `wta` dataset for this. Specifically, we are going to use the data from **2007**. Extracting this data isn't difficult but it is a little weird. The `wta` dataset is a list of `igraph`s, so you would think all that's necessary to get the first item in the list is to use `wta[1]`. Try a summary of this:

```{r}
summary(wta[40])
```

Interestingly, you didn't get the `igraph`! You got the list item but not what's in it. To get that, you actually need to use a double bracket: `wta[[1]]`.

```{r}
class(wta[[40]]) # extract with the double bracket, list with the single
```

So, this is a directed, named, weighted dataset with **255** players and **1,771** edges where the edge weights denote the number of times the "from" player lost to the "to" player on a specific surface type. Let's store this as `g`.

```{r}
g <- wta[[40]] # storing just the 40th igraph in the wta dataset list for year 2007
```

Now, getting a look at the actual values of the matrix of node attributes or edge attributes is actually not obvious; however, if we convert this using a `as_tbl_graph()` with `tidygraph`, we can make this much easier.

```{r}
library(tidygraph)
g2 <- as_tbl_graph(g)
```

Now, these objects are interesting because we can activate either the nodes or the edges (whatever we want to work with.) When we work with one set (for example, by applying filtering), the other set is also affected. We have to be careful though, because edge filtering won't necessarily remove all corresponding nodes, but removing a node will absolutely remove all edges attached to that node. We should note that there are **55** total countries represented here. This is going to be a bit much to draw, so we're going to limit our dataset.

```{r display_num_unique_countries}
length(unique(V(g2)$country))
```

In order to perform operations on this, we need to activate either nodes or edges and then apply our filter operations using `filter()`. This works exactly the same as it does in the `tidyverse` methodology and can be found easily online.

```{r}
g3 <- g2 |>
  activate("nodes") |>
  filter(country %in% c("USA", "GBR", "AUS")) |>
  filter(!node_is_isolated())
```

Saving your data at this point is a good idea. You can do this with `write_graph()` as follows.

```{r}
write_graph(g3, format = "gml", file = gml_filename)
```

Now, it's time to do our work:

`r if(SKIP_AHEAD) {"\\end{comment}"}`

# 2.) Graph with `ggraph`

![](igraph plot.png)

Your job is to produce the code/graph which reproduces or improves on this graph using the `ggraph` and `visNetwork` packages. Good luck!

---

**Answer:**

First off, let's take a look at this graph and note the important features:
```
 - There are **4** legends at each of the 4 corners:
  - vertex color based on `country` in bottom right, shown as fill of squares for icons in red, yellow, blue for USA, AUS, GBR respectively
  - vertex size based on `age` (legend only showing min, max) in bottom left
  - vertex shape based on `hand` (legend showing U, R, L) in top right
  - edge color based on `surface` (legend showing Hard, Grass, Clay, Carpet)
 - We can see one isolated component to the right, with **4** nodes, and a main more-connected component to the center
 - edge thickness does seem to vary, but it does not have a legend associated with it (assuming based on strength/degree?)
 - title top center: "Tennis Losses from 2007", color black, bolded
 - subtitle top center (below title): "Data represents players from USA, GBR, and AUS", color black, normal font size
 - caption bottom center: "Data from `networkdata` R package", wta dataset, color gray, small
 - edge arrow style is ... kinda weird. The arrows are offset back down towards the source of the arrow. (maybe there is a arrow offset param to adjust?)
```

Now, using each of those bullet points becomes a code chunk beginning:

```{r prepare_the_graph_data}
# first, read in the gml as a igraph obj
g <- igraph::read_graph(gml_filename, format = "gml")

```


```{r plot_the_graph_data, fig.height = 9, fig.width = 16}
# plot and layout settings

# Shape mapping (3 shapes)
node_types <- sort(unique(V(g)$hand)) # hand should be one of L, R, U
shape_vals <- c(21, 22, 24)[seq_along(node_types)]
shape_map <- setNames(shape_vals, node_types)

p <- ggraph(g, layout = "lgl") +

# vertex settings
# - vertex color based on `country`
# - vertex size based on `age`
# - vertex shape based on `hand`
    geom_node_point(
    aes(
      size = scales::rescale(age, to = c(5, 25)),
      color = country,
      shape = hand
      ),
    alpha = 0.6
  ) +
  geom_node_text(
    aes(
      label = name
      ),
    repel = TRUE,
    size = 3
  ) +

# edge settings
# - edge thickness does seem to vary, but it does not have a legend associated with it (assuming based on strength/degree?)
# - edge arrow style is ... kinda weird. The arrows are offset back down towards the source of the arrow. (maybe there is a arrow offset param to adjust?)
# - edge color based on `surface`
  geom_edge_arc(
    aes(
      color = surface,
      # linetype = type, # this line /also/ triggers the noted error below! Argh!
      #width = weight
      ),
    alpha = 0.8,
    lineend = "round",
    arrow = arrow(length = unit(3, "mm"), type = "closed"),
    end_cap = circle(2, "mm"),
    strength = 0.3
  ) +

# legends
# - There are 4 legends at each of the 4 corners:
#  - vertex color based on `country` in bottom right, shown as fill of squares for icons in red, yellow, blue for USA, AUS, GBR respectively
#  - vertex size based on `age` (legend only showing min, max) in bottom left
#  - vertex shape based on `hand` (legend showing U, R, L) in top right
#  - edge color based on `surface` (legend showing Hard, Grass, Clay, Carpet)
  scale_size_continuous(name = "Age", range = c(1, 8)) +
  #scale_shape_manual(values = shape_map, guide = "none") +
  #scale_edge_width(range = c(0.5, 1.5), guide = "none") +
  # scale_edge_linetype(guide = "none") + # this line triggers the below error! see note at end of chunk! # TODO look into this
guides() + # default guides
  # guides(
  #   size = guide_legend(nrow = 2, byrow = TRUE),
  #   # fill = guide_legend(
  #   #   nrow = 1, byrow = TRUE, title = "Vertex Color",
  #   #   override.aes = list(fill = vertex_colors)
  #   # ),
  #   # edge_color = guide_legend(
  #   #   ncol = 2, byrow = TRUE,
  #   #   title = "Surface Type"
  #   # )
  # ) +
  
# titles and text
# - title top center: "Tennis Losses from 2007", color black, bolded
# - subtitle top center (below title): "Data represents players from USA, GBR, and AUS", color black, normal font size
# - caption bottom center: "Data from networkdata R package", wta dataset, color gray, small
  labs(
    title    = "Tennis Losses from 2007",
    subtitle = "Data represents players from USA, GBR, and AUS",
    caption  = "Data from `networkdata` R package"
  ) +
  theme_graph()
p
```

# 3.) Graph with `visNetwork`

```{r prepare_visnetwork_graph_data}

library("igraph", quietly = TRUE, warn.conflicts = FALSE, verbose = FALSE)
data <- visNetwork::toVisNetworkData(g, idToLabel = FALSE)

# we currently have an igraph object with all our data in it. Let's convert it to data.frames for visNetwork consumption
nodes <- data$nodes
edges <- data$edges
```

```{r plot_visnetwork_graph}
visNetwork(nodes, edges, height = "800px", width = "100%") |>
  visNodes(color = list(background = "lightblue", 
                        border = "darkblue",
                        highlight = "yellow"),
           shadow = list(enabled = TRUE, size = 10)
           ) |>
  visEdges(shadow = TRUE,
           arrows = list(
             to = list(enabled = TRUE, scaleFactor = 2) # enable and doublesize to arrows
             ),
           color = list(
             color = "lightblue", # make 'em pretty
             highlight = "red")
           ) |>
  visLayout(randomSeed = 12) # TODO remove me before submit!
```

```{r try_the_visigraph_plot}
visNetwork::visIgraph(g, idToLabel = FALSE, physics = TRUE)

```

Well, while `physics = TRUE` is rather amusing to toy with, I'm still not getting any edges showing up... Let's investigate. Further investigation into this issue can be found in the appendices at the end. The TL;DR would be that the edge list has to/from columns as the strings of the player names, **not** the ids, which are required for `visNetwork`.

I'll have to replace the strings with their `id` programmatically, so let's program some helper functions that will likely make things go easier:

```{r helper_funcs}

# # converts vertex `name` string to int `id` from graph `nodes`
# name_to_id <- function(name, nodes = nodes) {
#   id_df <- nodes |>
#     rownames_to_column(var = "rowname") |>
#     filter(rowname == name) |>
#     select(id)
#   id <- id_df[[1]] # extract id from df
#   id # TODO some kind of error checking. If name is not found in nodes, this func shits the bed
# }
# 
# 
# get_node_id_from_name <- function(nodes, name) {
#   print("get_node_id_from_name() call")
#   print(nodes)
#   print(name)
#   id_df <- nodes |>
#     filter(name == name) |>
#     select(id)
#   id_df[[1]]
# }
# 
# get_node_id_from_name_vec <- Vectorize(get_node_id_from_name)
# 
# get_node_name_from_id <- function(nodes, id) {
#   print("get_node_name_from_id() call")
#   print(nodes)
#   print(id)
#   name_df <- nodes |>
#     filter(id == id) |>
#     select(name)
#   name_df[[1]]
# }
# 
# get_node_name_from_id_vec <- Vectorize(get_node_name_from_id)
# 
# # test:
# get_node_id_from_name(nodes, "Lauren Albanese") # = 14
# get_node_name_from_id(nodes, 14) # "Lauren Albanese"
# 
# get_node_id_from_name(nodes, "Samantha Stosur") # = 23
# get_node_name_from_id(nodes, 23) # "Samantha Stosur"
# 
# get_node_id_from_name(nodes, "Alicia Molik") # = 3
# get_node_name_from_id(nodes, 3) # "Alicia Molik"

# these helper functions are fine and dandy, but because I wrote them to handle the nodes variable after converting the igraph obj to visNetwork, and in doing so, I lost much of the useful functionality of igraph. In the future, I'll keep the graph as an igraph and manipulate it then, and only then plot and do visNetwork and things... I also tried to Vectorize the functions, but that wasn't needed in the end, and produced some interesting output...

# using the igraph obj g, let's rewrite our function a bit differently
get_node_id_from_name <- function(g, name) {
  which(V(g)$name == name)
}
```

```{r fix_the_bad_juju_pt1}
# first, let's fix the from column:

# I'm gonna learn the *apply() family, the purrr package and all the various map style functions god damnit.

# it would make sense to start with vapply, as I'm wanting a numeric vector output (the id)
# vapply(edges$from, name_to_id)
# Error in vapply(edges$from, name_to_id) : argument "FUN.VALUE" is missing, with no default

# vapply(edges$from, FUN = name_to_id)
# Error in vapply(edges$from, FUN = name_to_id) :
#   argument "FUN.VALUE" is missing, with no default

# vapply(edges$from, FUN = name_to_id, FUN.VALUE = NULL)
# Error in vapply(edges$from, FUN = name_to_id, FUN.VALUE = NULL) :
#   'FUN.VALUE' must be a vector

# vapply(edges$from, FUN = name_to_id, FUN.VALUE = c(0))
# Error in rownames_to_column(nodes, var = "rowname") :
# is.data.frame(df) is not TRUE

# so it's complaining about the datatype of the data parameter I'm passing in.... Okay...
# let's investigate its data type and class and obj structure
#edges$from # dumps whole vector data
#class(edges$from) # "character" vector
#str(edges$from) # chr vector, 1:38

# So we see that our edges object is a vector (length 38) of chrs of various lengths
# class is character
# str shows vector datatype, index range/length of vector and contents

# maybe give sapply a shot? using third parameter to pass nodes obj for get_node_id_from_name

#test <- sapply(E(g)$_from, FUN = get_node_id_from_name, nodes = nodes) # TODO WTF ALSKDJF LSDKJ FL
#str(test)

get_node_id_from_name <- function(name, g = g) {
  which(V(g)$name == name)
}

sapply(E(g)$from, get_node_id_from_name, g = g)
```


```{r fix_the_bad_juju_pt2}
# now, the to column:
#edges$to # TODO do same thing as above, vapply(edges$to, f)


```

Now that we've remapped the edges from string labels to id integers again, we should be able to construct the visNetwork object anew and re-plot, and we _should_ get our edges back!

```{r plot_visnetwork_graph_take_two}
# let's try this again!
visNetwork(nodes, edges, height = "800px", width = "100%") |>
  visNodes(color = list(background = "lightblue",
                        border = "darkblue",
                        highlight = "yellow"),
           shadow = list(enabled = TRUE, size = 10)
           ) |>
  visEdges(shadow = TRUE,
           arrows = list(
             to = list(enabled = TRUE, scaleFactor = 2) # enable and doublesize to arrows
             ),
           color = list(
             color = "lightblue", # make 'em pretty
             highlight = "red")
           ) |>
  visLayout(randomSeed = 12) # TODO remove me before submit!
```





## Appendices

### A1: Why no edges?!?!

```{r setup_environment_like_it_was_to_reproduce}
# reproduce the original g and nodes/edges from the original graph above, just in case we modified it inadvertently above
g <- igraph::read_graph(gml_filename, format = "gml")
data <- visNetwork::toVisNetworkData(g, idToLabel = FALSE)

nodes <- data$nodes
edges <- data$edges
```

```{r edge_check}
glimpse(edges)
```

```{r nodes_check}
glimpse(nodes)
```

Reading through `?visNetwork` and `?toVisNetworkData` learned me some new information: the parameters `nodes` and `edges` passed into `visNetwork()` require id (an int) in the `to` and `from` columns, and the edges that their dumb helper function `toVisNetworkData()` failed to do, despite throwing the flag to _not_ convert id to label... Let's confirm that suspicion, correct that and continue...

```{r confirm_breaking_the_thing}
d_with_flag <- visNetwork::toVisNetworkData(g, idToLabel = TRUE)
d_without_flag <- visNetwork::toVisNetworkData(g, idToLabel = FALSE)

d_with_flag$nodes
d_without_flag$nodes
d_with_flag$edges
d_with_flag$edges
```

Comparing the `data.frame`s of nodes and edges from with and without the `idToLabel` flag set. So the `idToLabel` flag parameter in `toVisNetworkData()` doesn't do what I thought it does. If it's `TRUE`, it will add another column to the nodes `data.frame` called `label` containing the id... It doesn't seem to _convert_ anything past that, ie. it doesn't rename the from/to attributes of the edges to match the id.

So in conclusion, the `idToLabel` parameter in `toVisNetworkData()` (if `TRUE`) simply copies the `id` (dbl) to a column named `label` (also dbl) as shown below in a toy example:

```{r make_toy_graph}
# let's make a small simple graph with igraph
g <- igraph::make_full_graph(5, loops = FALSE, directed = FALSE)

node_attr_names <- c("Jim", "Joe", "Bob", "Bill", "Susan")
V(g)$name <- node_attr_names

g
```

```{r id_to_label_test}
#g <- igraph::from_data_frame(g = node_attr_names, from =, to=)

visNetwork_g_true <- visNetwork::toVisNetworkData(g, idToLabel = TRUE)
visNetwork_g_false <- visNetwork::toVisNetworkData(g, idToLabel = FALSE)

visNetwork_g_true$nodes
visNetwork_g_false$nodes
```

Here we can see that setting that flag to `TRUE` simply copied the `id` col to a new col `label`, with identical datatype. That's ... minorly useful I guess?

---
title: "STAT332 Statistical Analysis of Networks Sec 01 - Homework 2 - Prof. Joe Reid"
author: "Andrew Sparkes"
date: "`r Sys.Date()`"
output:
  html_document:
    self_contained: true
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) # default to echo all the things

library(readr)
library(igraph)
library(tidyverse)
library(RColorBrewer)
library(scales)
library(data.table)
library(gt)
library(testit)
library(testthat)
```

```{r user_configurable_settings}
node_filename <- "node_list.csv"
edge_filename <- "edge_list.csv"
```

```{r utility_functions}
# various utility functions, will inevitably put these in a utils.R library at some point
fruit_or_veg <- function(thing) {
  switch(thing,
         Apple = "Fruit", 
         Banana = "Fruit", 
         Carrot = "Vegetable",
         Date = "Fruit",
         Eggplant = "Fruit",
         Fig = "Fruit",
         Grapes = "Fruit",
         Horseradish = "Vegetable",
         "Unknown Frui-egetable!" # default case
         )
}

# after taking the time to make a pretty switch call in the previous function, it appears I don't need to classify, just test if fruit is true or false with a whitelist. Oh well, another quick utility function
is_fruit <- function(thing) {
  return(thing %in% c("Apple", "Banana", "Date", "Eggplant", "Fig", "Grapes"))
}


print_big_fancy_summary_table <- function(graph) {
  big_fancy_igraph_table <- data.table(
    Label = c(
      "Connected?", 
      "Simple?", 
      "Loops?", 
      "Multigraph?", 
      "Weighted?", 
      "Directed?", 
      "Acyclic?", 
      "Bipartite?", 
      "Tree?", 
      "Forest?",
      "Size:", 
      "Components:",
      "Isolate Proportion:", 
      "Density:", 
      "Diameter:", 
      "Average Path Length:"
      ),
    Value = c(
      is_connected(graph), 
      is_simple(graph), 
      any_loop(graph), 
      any_multiple(graph), 
      is_weighted(graph), 
      is_directed(graph), 
      is_acyclic(graph), 
      is_bipartite(graph), 
      is_tree(graph), 
      is_forest(graph),
      gorder(graph), 
      count_components(graph), 
      sum(degree(graph) == 0)/gorder(graph), 
      edge_density(simplify(graph)), 
      diameter(graph), 
      mean_distance(graph)
      )
  )
  big_fancy_igraph_table |> gt()
}


# this was actually quite handy as an utility func
print_igraph_attr <- function(graph) {
  print("--- Graph Attributes ------")
  print(graph_attr(graph))
  
  print("--- Vertex Attributes ------")
  print(vertex_attr(graph))
  
  print("--- Edge Attributes ------")
  print(edge_attr(graph))
}

# generic version of this function, without the third col of expected values
print_metadata_summary_table <- function(graph) {
  tbl <- data.table(
    Label <- c(
      "Directed?",
      "Weighted?",
      "Not Simple?",
      "Has Multiple Edges?",
      "Weakly Connected?",
      "Strongly Connected?",
      "# of Strongly-connected components:",
      "# of Weakly-connected components:"
    ),
    Value <- c(
      igraph::is_directed(graph),
      igraph::is_weighted(graph),
      !igraph::is_simple(graph),
      length(E(graph)) > 1,
      is_connected(graph, mode = "weak"), # mode = weak is the default
      is_connected(graph, mode = "strong"),
      components(graph, mode = "strong")$no,
      components(graph, mode = "weak")$no # mode = weak is the default
    )
  )
  tbl |> gt()
}

```

# Instructions:

Please complete this homework assignment by the due data posted on canvas. Please submit your work in an html file with solutions and code presented completely.

# Homework 2: Networks and visualization with igraph

## Question 1:

Create a .csv file using a spreadsheet software or notepad. This file should have **four** columns: from, to, weight, name. Create a network using an edge-list with **two** **strongly connected** components where the whole network is **weakly connected**. The network will have nodes called Apple, Banana, Carrot, Date, Eggplant, Fig, Grapes, and Horseradish (I'll just use letters for the rest of the instructions. A, B, C, D, and E are **strongly connected**, as are F, G, and H. Furthermore, the graph should be a **multigraph** where there are **two** paths from A to B and **three** paths from E to D. Generate a **weights** attribute by creating **random weights** between 0 and 1 for each of the edges. Finally, provide a **names** attribute for every edge denoting the edge: S1 if it's the first edge connecting two nodes, S2 if it's the second, and S3 if it's the third. The graph should have **no isolates**. Also, create a nodes file that has the names of the nodes in a column called **name** and a column called **type** that has values of Fruit and Vegetable depending on the observation.

### 1.a) 

Read in your edgelist. The following code can help.

```{r notes, collapse=TRUE}
# assorted notes to copy/paste from

# Node names:
# Apple, Banana, Carrot, Date, Eggplant, Fig, Grapes, and Horseradish

# Apple
# Banana
# Carrot
# Date
# Eggplant
# Fig
# Grapes
# Horseradish

# Create a network using an edge-list with two strongly connected components where the whole network is weakly connected (any node can reach any other node (ignoring directional edges))
```

Well. I couldn't bring myself to drag out a piece of paper and do these by hand, even though that probably would have been quicker and easier, but then I wouldn't get as much tinkering in with igraph and everything else, so I opted to generate the graph from the ground up using igraph, then spit out an edgelist to a csv, load it in and pretend I just started with an existing csv! So for that, I need to write my own edge_list.csv and node_list.csv. Creating a graph/network with a edge list is trivial with the igraph function, so my first task is to generate some subgraphs to glue together and once I've constructed it in igraph, I can export it as an edge list to a csv, then load it and do whatever from there...

For building up this graph, we'll begin by dividing the problem in half; into two components. The first component/subgraph has 5 nodes and is strongly connected (all nodes are connected to every other node) while the second has 3 nodes and is also strongly connected. We then combine those two graphs together, add in the edges that link the two components/subgraphs, and then verify that our constructed graph meets all the above criteria. Let's begin:

```{r create_the_first_component}
# A, B, C, D, and E are strongly connected.
# => strongly connected means there are paths between all pairs of vertices, so A/B/C/D/E are completely dense 
g1_vertex_labels <- c("A", "B", "C", "D", "E")
g1 <- igraph::make_full_graph(length(g1_vertex_labels), 
                      directed = TRUE, 
                      loops = FALSE
                      )
V(g1)$name <- g1_vertex_labels # assigning the lettered labels to the name of each vertex in the subgraph g1
```

Now, let's do a quick verification that we now have vertices with lettered labels:

```{r verify_first_component_creation}
V(g1) # to see labeled vertices
E(g1) # to see label vertices in edge pairs
plot(g1)
```

Excellent! Now we create the smaller second component:

```{r create_the_second_component}
# F, G, and H are strongly connected.
# => strongly connected means paths between all pairs, so F/G/H are all completely dense in their subgraph
g2_node_labels <- c("F", "G", "H")
g2 <- igraph::make_full_graph(length(g2_node_labels), 
                      directed = TRUE, 
                      loops = FALSE
                      )
V(g2)$name <- g2_node_labels # assigning the lettered labels to the name of each node in the subgraph g2
```

Now, a quick double check as usual:

```{r verify_second_component_creation}
V(g2) # to see labeled nodes
E(g2) # to see label nodes in edge pairs
plot(g2)
```

Now that we have two suitable looking components, let's merge them into a single igraph object:

```{r combine_the_components}
# now that we have the two complete subgraphs, we can combine them 
graph <- g1 + g2

# TODO graph now has some duplicated attributes like name_1 and name_2, fix me!
```

Ensuring our graph looks right after combining the two components into a larger graph, before adding edges between them (we should see two separate and disjoint complete subgraphs):

```{r plot_the_combined_graph}
graph
plot(graph)
```

Well, that there certainly looks like two disjoint components! Now we add the remaining edges to connect the two components/subgraphs:

```{r make_multigraph_edges}
# TODO figure this shit out FML

# multigraph where there are two paths from A to B and three paths from E to D
# => multigraph means more than one edge between a pair of vertices, so there are multiple entries in the edge list like: 
# (A, B, blah, blah) <- original edge in graph (first path)
# (A, B, blah2, blah2) <- second path
# as well as
# (E, D, blah, blah) <- original edge in graph
# (E, D, blah2, blah2)
# (E, D, blah3, blah3)
# BUT, the first linkage between A,B let's say is labeled S1, and only the "extra" edges connecting will be named S2 and S3, so we're really only adding 3 vertices.
# also consider that in a bidirectional graph, with all nodes being completely connected, as each component is
# So for A and B, we have A->B (named S1) and B->A (also named S1) but there will be a /second/ path from A->B (called S2) and 2x more for E->D (S2 and S3 respectively)

# graph is our combined igraph object, let's add those edges and label them!
# first, setup a df with the new edge data
data <- data.frame(
  from = c("A","E","E"), 
  to = c("B","D","D"), 
  name = c("S2", "S2", "S3"), 
  weight = runif(3)
  )

# actually add the edges to the graph
igraph::add_edges(
  graph,
  unlist(data[, c("from", "to")]), # hoping to get a list of (from1, to1, from2, to2, ...)
  attr = c(name = data[, c("name")], weight = data[, "weight"]) # TODO test this is passing attr properly
  )

# if the above works to set the edge attrs, won't need these next lines:

# set the name attribute for the edges
#graph <- set_edge_attr(E(graph), name = "name", value = data[, c("name")]) # note to self: set_edge_attr() sets ALL nodes in one fell swoop, so the dimensions of value vector must match length(E(graph))


# set the weight attribute for the edges too

```

Let's verify the graph now has edge attribute "name":

```{r}
E(graph)$name
```


```{r generate_and_assign_edge_weights}
# Generate a weights attribute by creating random weights between 0 and 1 for each of the edges
# runif(n) returns a vector of random decimals in [0,1]
E(graph)$weight = runif(length(E(graph)))
```

```{r verifying_added_weights}
E(graph)$weight
```


The graph should have no isolates:

```{r isolates_check}
# The graph should have no isolates
graph_degrees <- igraph::degree(graph) # gets all the vertex's degrees in col vector
num_of_isolates <- sum(graph_degrees == 0) # sum of all the entries that are ==0 aka isolated
# one of our examples stored the degrees for the nodes as node attributes, I wonder if this is a good default practice? Or only when needed?

testit::assert("There should be no isolates.", {
  num_of_isolates == 0
})
```


```{r load_the_nodes}
# create a nodes file that has the names of the nodes in a column called name and a column called type that has values of Fruit and Vegetable depending on the observation

tbl_nodes <- data.table(
  name = V(graph)$name, # pull the names directly from the vertices of the graph
  # Apple, Banana, Carrot, Date, Eggplant, Fig, Grapes, and Horseradish
  type = lapply(V(graph)$name, fruit_or_veg) # type will be Fruit, Vegetable, or Unknown Frui-egetable! in the case of an unknown string # TODO look up exceptions/error handling/parameter typechecking/validation/etc in R
)
tbl_nodes |> gt()

# create the node file
#node_filename
#save csv
```


```{r load_the_edge_list}
edges <- readr::read_csv(
  edge_filename,
  header = TRUE,
  sep = ","
  )

# prune out the edge start and end vertices and dump them in edge_list
edge_list <- edges[, c("from", "to")]          
```

Once you have your edge list, convert it to an igraph object using the graph_from_data_frame() function (you may need the documentation).

```{r convert_igraph_to_df}
ig_from_df <- igraph::graph_from_data_frame(d = edge_list)
```

### 1.b)

Produce a summary of your graph to make sure the igraph works correctly.

```{r assert_igraph_class}
testit::assert(paste0("ig object should be of class: igraph, but returned class: ", class(graph)), {
  class(graph) == "igraph"
})
```


```{r print_ig_as_string}
print("Printing raw object as string representation:")
graph
```

---

```{r print_summary}
print("--- Summary ---")
summary(graph)
```

---

```{r print_metadata_summary}
print("--- Metadata Summary ---")
print_metadata_summary_table(graph)
```

---

```{r print_graph_vertex_edge_attr}
print("--- Graph, Vertex and Edge Attributes ---")
print_igraph_attr(graph)
```

---

```{r print_obnoxiously_long_summary}
print("--- Graph Summary With All The Things ---")
print_big_fancy_summary_table(graph)
```

---


### 1.c)

In Lab 2 we looked at how to create a summary of the metadata for the graph. Use this code as a basis to make sure that the above conditions are met in general (Directed, Weigted, Not Simple, Has Multiple Edges, is weakly connected but not strongly connected, has two components when counting the number of strongly connected components but only one when counting the number of weakly connected components.

```{r}
print_metadata_summary_w_compare <- function(graph) {
  tbl <- data.table(
    Label <- c(
      "Directed?",
      "Weighted?",
      "Not Simple?",
      "Has Multiple Edges?",
      "Weakly Connected?",
      "Strongly Connected?",
      "# of Strongly-connected components:",
      "# of Weakly-connected components:"
    ),
    Value <- c(
      igraph::is_directed(graph),
      igraph::is_weighted(graph),
      !igraph::is_simple(graph),
      length(E(graph)) > 1,
      is_connected(graph, mode = "weak"), # mode = weak is the default
      is_connected(graph, mode = "strong"),
      components(graph, mode = "strong")$no,
      components(graph, mode = "weak")$no # mode = weak is the default
    ),
    Expected <- c(
      TRUE, # Directed
      TRUE, # Weighted
      TRUE, # Not Simple
      TRUE, # Has Multiple Edges
      TRUE, # Weakly Connected
      FALSE, # Strongly Connected
      2, # Strongly-Connected Components
      1 # Weakly-Connected Components
    )
  )
  tbl |> gt()
}


print_metadata_summary_w_compare(graph)
# I feel like this is an appropriate place to employ tests and asserts properly, but I need to delve more into testing in R
```

---

```{r set_weighted_and_directed_attrs}
graph <- set_graph_attr(graph, name = "Weighted", value = TRUE)
graph <- set_graph_attr(graph, name = "Directed", value = TRUE)
```


```{r reference_code}
# REFERENCE
# degree(   
#   graph,   
#   v = V(graph),   
#   mode = c("all", "out", "in", "total"),   
#   loops = TRUE,   
#   normalized = FALSE
#   )
# strength(   
#   graph,   
#   vids = V(graph),   
#   mode = c("all", "out", "in", "total"),   
#   loops = TRUE,   
#   weights = NULL 
#   )
# g <- set_vertex_attr(g, name = "degree_in", value = strength(g, mode = "in"))
# g <- set_vertex_attr(g, name = "degree_out", value = strength(g, mode = "out"))
# g <- set_vertex_attr(g, name = "degree_total", value = strength(g, mode = "total"))
# components(g, mode = "strong")
# components_results <- components(g, mode = "strong")
# components_results$membership
# g <- set_vertex_attr(g, 
#                 name = "component", 
#                 value = components(g, mode = "strong")$membership)
# plot(
#   g,
#   oma = c(2,3,5,2)
#   )
# title = "Media Networks Link to and Reference Eachother"
# subtitle = "A network plot of networks."
# caption = "Data from:  https://kateto.net/network-visualization."
# mtext(side = 3, line = 3, at = -2, adj = 0, cex = 1.1, title)
# mtext(side = 3, line = 2, at = -2, adj = 0, cex = 0.7, subtitle)
# mtext(side = 1, line = 2, at = -2, adj = 0, cex = 0.5, caption )
# 
# 
# 
# plot_params <- list(
#   x = g,
#   layout = layout,
#   
#   vertex.size = node_sizes,
#   vertex.color = adjustcolor(node_colors, alpha.f = transparency),
#   vertex.frame.width = frame_width,
#   vertex.frame.color = frame_color,
#   vertex.shape = node_shapes,
#   
#   vertex.label = vertex attribute
#   vertex.label.cex
#   vertex.label.color
#   vertex.label.dist
#   
#   edge.width = edge_widths,
#   edge.color = adjustcolor(edge_colors, alpha.f = transparency),
#   edge.lty = as.numeric(edge_styles),
#   edge.curved = a number between -0.5 and 0.5
#   
#   edge.label = edge attribute for label
#   edge.label.cex = edge label size
#   edge.label.color = edge label color
#   
#   edge.arrow.size <- edge.width * 0.35 (this will dynamically adjust them)
#   edge.arrow.mode <- one of: ">" = 2,"<" = 1, "<>" = 3,"-" = 0)
#   
#   rescale = TRUE
#   
#   main = "",  # We'll add titles manually for better control
#   sub = "",
#   xlab = "",
#   ylab = ""
# )
```

Wait a minute. If you used the same work we did in lab, you will find out that this graph is NOT WEIGHTED! That can't be right. Well, I suppose it can because we don't have the right edge properties on this graph.

### 1.d)

I guess we better add the other elements from the edges matrix into our graph as edge attributes.

```{r planning_and_thinking}
# add the other elements from the edges matrix into our graph as edge attributes
# ig is our igraph object, with the vegetable/fruit names for vertex names, etc
# add the other elements... from the edges matrix... OHHHHH, I'm dumb... "edges matrix" is the edge list csv... duh...
```


```{r look_at_existing_attributes}
# first, let's remind ourselves what attributes are already present in the graph
print_igraph_attr(graph)
```

```{r adding_edge_attributes}
# okay, there are 4 columns in the edgelist csv: to, from (both of which are nodes), weight (of the edge), and name (of the edge)
# therefore, my goal is to add the edge weights and the edge names
name_list <- edge_list$name # TODO try this. maybe it works? maybe?
weight_list <- edge_list$weight # TODO to be tested
graph <- igraph::set_edge_attr(graph, "name", name_list)
graph <- igraph::set_edge_attr(graph, "weight", weight_list)
```

Let's verify that those attributes got added onto our igraph object:

```{r verify_added_edge_attributes}
print_igraph_attr(graph)
```

Also, read in your nodes file the same way you did for the edges file and update the vertex property with the types.

```{r load_dem_nodes}
# read in your nodes file
node_list <- readr::read_csv(node_filename, header = TRUE, sep = ",")
name_list <- node_list[, c("name")]
type_list <- node_list[, c("type")]
```

Now, we have the nodes list csv file loaded, and have pulled out the columns for name and type for later use.

```{r update_vertex_attributes}
# update the vertex property with the types
# assuming this means to use the data inside nodes_list as the type attribute of the vertices? If I'm understanding that right? node_list.csv will have columns: name (to identify the vertex, assuming vertex letter, not name?), type (to identify the type), and ...
graph <- igraph::set_vertex_attr(graph, "name", name_list)
graph <- igraph::set_vertex_attr(graph, "type", type_list)
```

Let's verify we see vertex name and vertex type in our igraph:

```{r verify_vertex_attributes}
print_igraph_attr(graph)
```

---

```{r verify_vertex_attributes_alternative}
V(graph)$name
V(graph)$type
```

---

Finally, produce a summary of the graph again. You should see that, because you have a column called weight, the summary is now: DNWB 8. This means it is a weighted graph.

```{r igraph_summary_after_adding_vertex_attrs}
# nicely formatted table of various metrics for the graph and compare:
igraph::summary(graph)
```

---

```{r print_metadata_for_graph_after_attrs}
print_metadata_summary_table(graph) # to compare to the default igraph summary (also has is_weighted call in there)
```

That looks good to me!

### 1.e)

Produce a quick plot of the graph to make sure it looks like you expected.

```{r ugly_plot}
# quick, dirty, ugly plot
plot(graph)
```

### 2.)  Graphing

Now, we are going to work on improving the plot, but we actually have a problem. The vertex name of "type" is actually a reserved term. This one is supposed to be a logical of 1 or 0. We need to rename our vertex attribute of "type" to "classification" and then overwrite the "type" variable. I'll give you this code.

```{r rename_type_to_classification}
V(ig)$classification <- V(ig)$type
```

Of note, the edge attribute _type_ still exists at this point, to be overwritten in the next code block:

```{r assign_type_based_on_fruit}
# so if it's a fruit type, it gets a TRUE, else FALSE
V(ig)$type <- ifelse(V(ig)$classification == "Fruit", TRUE, FALSE) # so type isn't /really/ a "type" anyone, it's an is_fruit bool flag... Got it.
```

Now, start by using the layout_as_bipartite in your plot.

```{r setup_bipartite_graph_params}
l <- igraph::layout_as_bipartite(
  graph = ig,
  types = NULL, # NULL => will read vertex.type as type
  hgap = 5,
  vgap = 5,
  maxiter = 1000
)
```


```{r setup_bipartite_graph_plot_params}
par(mar = c(3,1,4,1))
#par(oma = c(2,3,5,2))
```


```{r setup_bipartite_graph_vertex_params}
# ------------------------
# VERTEX COLORS 
# ------------------------
v_vals   <- V(g)$type.label
v_levels <- sort(unique(v_vals))

# Automated Color Identification
v_pal <- setNames(
  brewer.pal(length(v_levels), "Paired"),
  v_levels
)

# Manual Color Identification
  ## Example: color-blind friendly Okabe–Ito (first k colors will be used)
#okabe_ito <- c(
#  "#000000", "#E69F00", "#56B4E9", "#009E73",
#  "#F0E442", "#0072B2", "#D55E00", "#CC79A7"
#)

  ## Build a named palette by aligning colors to the detected levels
## If there are more levels than colors, we recycle (or you can stop with an error)
#user_colors <- okabe_ito  # or any vector like c("#AABBCC", "#DDEEFF", ...)
#v_pal <- setNames(user_colors[seq_along(v_levels)], v_levels)

vertex_colors <- v_pal[v_vals]


## ---- (b) Continuous palette (if needed) ----
# library(scales)
# pal_cont <- col_numeric("viridis", domain = range(V(g)$some_number))
# vertex_colors <- pal_cont(V(g)$some_number)



# ------------------------
#  VERTEX SHAPES
# ------------------------

shape_levels <- levels(as.factor(v_vals))
shape_pal <- setNames(c("circle", "square", "rectangle")[seq_along(shape_levels)], shape_levels)
vertex_shapes <- shape_pal[v_vals]
```


```{r setup_bipartite_graph_edge_params}
# ------------------------
#  EDGE COLORS 
# ------------------------
e_vals   <- E(g)$type
e_levels <- sort(unique(e_vals))

e_pal <- setNames(
  brewer.pal(length(e_levels), "Paired"), # Paired is the name of the palette from color brewer. 
  e_levels
)

edge_colors <- e_pal[e_vals]

## ---- (b) Continuous palette (if needed) ----
# pal_cont <- col_numeric("viridis", domain = range(E(g)$some_number))
# edge_colors <- pal_cont(E(g)$some_number)

# ------------------------
#  EDGE LINE TYPES (discrete)
# ------------------------
e_lty_vals   <- E(g)$type
e_lty_levels <- sort(unique(e_lty_vals))

# assign linetypes to the levels
lty_palette <- c(1, 2)  # or however many you want
e_lty_pal <- setNames(
  lty_palette[seq_along(e_lty_levels)],
  e_lty_levels
)

edge_line_types <- e_lty_pal[e_lty_vals]
```


```{r plot_the_bipartite_graph}
plot(
  ig,
  layout = layout_with_lgl,

  vertex.sizes = scales::rescale(V(g)$audience.size, to = c(5, 25)),
  vertex.color = adjustcolor(vertex_colors, alpha.f = 0.5),
  vertex.shape = vertex_shapes,

  vertex.label = V(g)$media,
  vertex.label.cex = 0.7,
  vertex.label.dist = 0.5,

  edge.widths = scales::rescale(E(g)$weight, to = c(0.5, 3)),
  edge.color = edge_colors,
  edge.lty = edge_line_types,

  edge.curved = 0.35,
  edge.label = E(g)$weight,
  edge.label.cex = 0.6,

  edge.arrow.size = scales::rescale(E(g)$weight, to = c(0.5, 3))*0.3,
  edge.arrow.mode = 1
)
```


```{r add_the_legends}
legend(
  "topright",
  title = "Vertex Type",
  legend = v_levels,
  fill   = v_pal[v_levels],
  border = NA,
  bty = "n",
  cex = 0.8
)



shape_pch_map <- c(
  circle     = 21,
  square     = 22,
  rectangle  = 22,  
  csquare    = 22,
  crectangle = 22
)

legend(
  "topleft",
  title = "Vertex Shape",
  legend = shape_levels,
  pch    = shape_pch_map[ shape_pal[shape_levels] ],
  pt.bg  = "gray80",
  bty = "n",
  cex = 0.8
)



legend(
  "bottomright",
  title = "Edge Type",
  legend = e_levels,
  col    = e_pal[e_levels],
  lwd    = 3,
  bty = "n",
  cex = 0.8
)



legend(
  "bottomleft",
  title = "Edge Line Type",
  legend = e_lty_levels,
  lty    = unname(e_lty_pal[e_lty_levels]),
  lwd    = 3,
  bty = "n",
  cex = 0.8
)
```

```{r add_the_title_subtitle_caption}
title_text <- "Media Networks Link to and Reference Each Other"
subtitle_text <- "A network plot of networks."
caption_text <- "Data from: https://kateto.net/network-visualization."

mtext(side = 3, line = 2, at = 0, adj = 0.5, cex = 1.1, title_text) # 3 = top, adj = 0.5 is centered
mtext(side = 3, line = 1, at = 0, adj = 0.5, cex = 0.8, subtitle_text)
mtext(side = 1, line = 1, at = 0, adj = 0.5, cex = 0.6, caption_text) # side = 1 is bottom, line = 1 is line 1, away from plot
```

You should see a two row format for the results. Now, we need to make this look better.

### 1.e)  

Your final task on this will be to make this look better based on the lab from class. Create colors, use transparency, label edges, change shapes and thicknesses, etc... The one requirement is that you calculate the in-degree of the nodes, store this as a vertex attribute, and use that to size the vertex. Add a title, subtitle, and caption to the graph, and make sure to use legends.

```{r make_it_colorful}
# Create colors
# use transparency
# in plot_params:
vertex.color = adjustcolor(node_colors, alpha.f = trans)
vertex.label.color = adjustcolor(node_label_colors, alpha.f = trans)
edge.color = adjustcolor(edge_colors, alpha.f = trans)
edge.label.color = adjustcolor(edge_label_colors, alpha.f = trans)
```


```{r}
# label edges
# in plot_params:
# edge.label = edge_labels # (a vector of string labels)
```


```{r}
# change shapes
# in plot_params:
# vertex.shape = node_shapes # (a vector of shape character codes)
```


```{r}
# change thicknesses
# in plot_params:
# edge.width = edge_widths # (a vector of edge widths)
```


```{r}
#, etc...
```


```{r}
# calculate the in-degree of the nodes, store this as a vertex attribute
graph <- set_vertex_attr(graph, name = "degree_in", value = strength(graph, mode = "in"))
```


```{r}
# use the indegree of the node to size the vertex
# in plot_params:
# vertex.label.cex = scales::rescale(V(graph)$degree_in, c(1, 4)) # [1,4] is just a guess, verify and adjust
```


```{r graph_title_final_touches}
# Add a title
title = "Media Networks Link to and Reference Eachother"
mtext(side = 3, line = 3, at = -2, adj = 0, cex = 1.1, title)

# subtitle
subtitle = "A network plot of networks."
mtext(side = 3, line = 2, at = -2, adj = 0, cex = 0.7, subtitle)

# caption
caption = "Data from:  https://kateto.net/network-visualization."
mtext(side = 1, line = 2, at = -2, adj = 0, cex = 0.5, caption )

# legends
#legend()
```

```{r}
# JUST FOR REFERENCE AND COPY/PASTING
library(RColorBrewer)
library(scales)

#___________________________________________
## PLOT PROPERTIES
#___________________________________________
par(mar = c(3,1,4,1))
#par(oma = c(2,3,5,2))



#___________________________________________
## VERTEX PROPERTIES
#___________________________________________

# ------------------------
# VERTEX COLORS 
# ------------------------
v_vals   <- V(g)$type.label
v_levels <- sort(unique(v_vals))

# Automated Color Identification
v_pal <- setNames(
  brewer.pal(length(v_levels), "Paired"),
  v_levels
)

# Manual Color Identification
  ## Example: color-blind friendly Okabe–Ito (first k colors will be used)
#okabe_ito <- c(
#  "#000000", "#E69F00", "#56B4E9", "#009E73",
#  "#F0E442", "#0072B2", "#D55E00", "#CC79A7"
#)

  ## Build a named palette by aligning colors to the detected levels
## If there are more levels than colors, we recycle (or you can stop with an error)
#user_colors <- okabe_ito  # or any vector like c("#AABBCC", "#DDEEFF", ...)
#v_pal <- setNames(user_colors[seq_along(v_levels)], v_levels)

vertex_colors <- v_pal[v_vals]


## ---- (b) Continuous palette (if needed) ----
# library(scales)
# pal_cont <- col_numeric("viridis", domain = range(V(g)$some_number))
# vertex_colors <- pal_cont(V(g)$some_number)



# ------------------------
#  VERTEX SHAPES
# ------------------------

shape_levels <- levels(as.factor(v_vals))
shape_pal <- setNames(c("circle", "square", "rectangle")[seq_along(shape_levels)], shape_levels)
vertex_shapes <- shape_pal[v_vals]




#___________________________________________
## EDGE PROPERTIES
#___________________________________________


# ------------------------
#  EDGE COLORS 
# ------------------------
e_vals   <- E(g)$type
e_levels <- sort(unique(e_vals))

e_pal <- setNames(
  brewer.pal(length(e_levels), "Paired"), # Paired is the name of the palette from color brewer. 
  e_levels
)

edge_colors <- e_pal[e_vals]

## ---- (b) Continuous palette (if needed) ----
# pal_cont <- col_numeric("viridis", domain = range(E(g)$some_number))
# edge_colors <- pal_cont(E(g)$some_number)

# ------------------------
#  EDGE LINE TYPES (discrete)
# ------------------------
e_lty_vals   <- E(g)$type
e_lty_levels <- sort(unique(e_lty_vals))

# assign linetypes to the levels
lty_palette <- c(1, 2)  # or however many you want
e_lty_pal <- setNames(
  lty_palette[seq_along(e_lty_levels)],
  e_lty_levels
)

edge_line_types <- e_lty_pal[e_lty_vals]





# ------------------------
# 5. PLOT
# ------------------------
plot(
  g,
  layout = layout_with_lgl,

  vertex.sizes = scales::rescale(V(g)$audience.size, to = c(5, 25)),
  vertex.color = adjustcolor(vertex_colors, alpha.f = 0.5),
  vertex.shape = vertex_shapes,

  vertex.label = V(g)$media,
  vertex.label.cex = 0.7,
  vertex.label.dist = 0.5,

  edge.widths = scales::rescale(E(g)$weight, to = c(0.5, 3)),
  edge.color = edge_colors,
  edge.lty = edge_line_types,

  edge.curved = 0.35,
  edge.label = E(g)$weight,
  edge.label.cex = 0.6,

  edge.arrow.size = scales::rescale(E(g)$weight, to = c(0.5, 3))*0.3,
  edge.arrow.mode = 1
)

# ------------------------
# 8. LEGENDS
# ------------------------


legend(
  "topright",
  title = "Vertex Type",
  legend = v_levels,
  fill   = v_pal[v_levels],
  border = NA,
  bty = "n",
  cex = 0.8
)



shape_pch_map <- c(
  circle     = 21,
  square     = 22,
  rectangle  = 22,  
  csquare    = 22,
  crectangle = 22
)

legend(
  "topleft",
  title = "Vertex Shape",
  legend = shape_levels,
  pch    = shape_pch_map[ shape_pal[shape_levels] ],
  pt.bg  = "gray80",
  bty = "n",
  cex = 0.8
)



legend(
  "bottomright",
  title = "Edge Type",
  legend = e_levels,
  col    = e_pal[e_levels],
  lwd    = 3,
  bty = "n",
  cex = 0.8
)



legend(
  "bottomleft",
  title = "Edge Line Type",
  legend = e_lty_levels,
  lty    = unname(e_lty_pal[e_lty_levels]),
  lwd    = 3,
  bty = "n",
  cex = 0.8
)


# ------------------------
# 7. TITLES
# ------------------------
title_text <- "Media Networks Link to and Reference Each Other"
subtitle_text <- "A network plot of networks."
caption_text <- "Data from: https://kateto.net/network-visualization."

mtext(side = 3, line = 2, at = 0, adj = 0.5, cex = 1.1, title_text)
mtext(side = 3, line = 1, at = 0, adj = 0.5, cex = 0.8, subtitle_text)
mtext(side = 1, line = 1, at = 0, adj = 0.5, cex = 0.6, caption_text)
```

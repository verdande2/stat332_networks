---
title: "STAT332 Statistical Analysis of Networks Sec 01 - Lab 6 - Prof. Joe Reid"
author: "Andrew Sparkes"
date: "`r Sys.Date()`"
due: "27-02-2026"
output:
  html_document:
    self_contained: true
    df_print: paged
    code_folding: hide
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```


```{r user_configurable_settings}

```

## 1.) Setup

Welcome to Lab . We are going to look at micro-scale measures and
structures this week.\
These are node and edge level properties that allow us to discover
properties of micro-level elements of the network based on their
position, relations, and structures. We're going to need a plot that
looks okay here, so let's create something that looks nice.

```{r}
library(ggplot2)
library(gridExtra)


plot_dist <- function(x,
                      title = NULL,
                      xlab = NULL,
                      fill_color = "#4C72B0",
                      density_color = "#DD8452",
                      bins = 30) {

  x <- x[is.finite(x)]
  df <- data.frame(value = x)

  p_hist <- ggplot(df, aes(x = value)) +
    geom_histogram(
      aes(y = after_stat(density)),
      bins = bins,
      fill = fill_color,
      color = "white",
      alpha = 0.85
    ) +
    geom_density(
      color = density_color,
      linewidth = 1.1,
      adjust = 1.1
    ) +
    labs(
      title = title,
      x = xlab,
      y = "Density"
    ) +
    theme_minimal(base_size = 13) +
    theme(
      plot.title = element_text(face = "bold"),
      panel.grid.minor = element_blank()
    )

  p_box <- ggplot(df, aes(x = value, y = "")) +
    geom_boxplot(
      fill = fill_color,
      alpha = 0.55,
      outlier.color = density_color,
      outlier.size = 2
    ) +
    theme_minimal(base_size = 13) +
    theme(
      axis.title.y = element_blank(),
      axis.text.y  = element_blank(),
      axis.ticks.y = element_blank(),
      panel.grid   = element_blank()
    ) +
    labs(x = xlab)

  gridExtra::grid.arrange(p_hist, p_box, heights = c(3, 1))
}

```

## 2.) Lab Walkthrough

### 2.a) Getting started.

```{r}
library(igraph) 
g <- readRDS("brain_shape_map.rds")
```

As always, let's make sure we print out our vertex and edge attributes

```{r}
summary(g)
```

So 45 nodes with 463 edges. Directed, but not weighted.

And again, lets use a summary for finding out other properties.

```{r, message = FALSE, warning=FALSE}
library(data.table)
library(gt)

ID = c("Order", "Size", "Connected", "Directed", "Acyclic", "Weighted", "Simple", "Has Loops", "Is Multigraph", "Bipartite", "Tree", "Forest")
  
Value = c(gorder(g), ecount(g), is_connected(g), is_directed(g), is_acyclic(g), is_weighted(g), is_simple(g), any_loop(g), any_multiple(g), is_bipartite(g), is_tree(g), is_forest(g))
  
table <- data.table(ID, Value)
table %>% gt() %>% fmt_tf(columns = Value, tf_style = "yes-no")
```

It's connected, so we don't need to worry about the larges component.

![Visualization of the network for this
analysis](Brain_shape_network.png)

I think that's enough for the setup, so let's move on to our metrics

# 3.) Micro-scale properties ---

## 3a.) Articulation points and bridges ----

### Weak Articulation

Weak Articulation points are easy to calculate. These are the ones that
are built into igraph.

```{r}
weak_ap <- articulation_points(g)
weak_ap
```

### Strong Articulation

These are a little bit harder to find. (It's actually a currenlty open
request in igraph's github). It's actually very easy to calculate via
brute force, but a little bit slow.

```{r}
# Our graph is already strongly connected, so some of this is extra
strong_articulation_points <- function(g) {
  base <- components(g, mode = "strong")$no  # This is the number of nodes in the strongly connected component. 
  vids <- V(g)  # the vertex ideas from the graph g
  out <- vids[sapply(vids, function(v) {
    components(delete_vertices(g, v), mode = "strong")$no > base
  })]
  out # Return the ones that increase the number of components of the original graph
}

sap <- strong_articulation_points(g)
sap

```

So, there are actually no articulation points on this graph.

### Bridges

Interestingly, igraph also calculates bridges as unidrected by default.
i.e., any bridges detected automatically by igraph are weak bridges.

```{r}
bridges_g <- bridges(g)
E(g)[bridges_g]
```

So, to detect strong bridges, we have to do the same method as we did
for strong articulation points.

```{r}

strong_bridges <- function(g) {
  base <- components(g, mode = "strong")$no
  eids <- E(g)  #Get the edge ids of g
  keep <- sapply(eids, function(e) {
    components(delete_edges(g, e), mode = "strong")$no > base # Figure out which edges fracture the graph when removed.
  })
  eids[keep]
}

br_s <- strong_bridges(g)
br_s

```

So far, not very interesting. There are no articulation points or
bridges int this graph. That sounds bad, but it makes the rest of this
process a lot more interesting.

## 3b.) Degree

### In-Degree

```{r}
deg_in  <- degree(g, mode = "in")
deg_in
summary(deg_in)
```

```{r}
plot_dist(deg_in)
```

```{r}
V(g)$deg_in <- deg_in
```

### Out-Degree

```{r}
deg_out <- degree(g, mode = "out")
deg_out
summary(deg_out)
```

```{r}
plot_dist(deg_out)
```

```{r}
V(g)$deg_out <- deg_out
```

## 3c.) Centrality

### Normalized In-Degree Centrality

```{r}
deg_in_cent <- degree(g, v = V(g), mode = "in", loops = TRUE, normalized = TRUE)
deg_in_cent
summary(deg_in_cent)
```

```{r}
plot_dist(deg_in_cent)
```

```{r}
V(g)$deg_in_cent <- deg_in_cent
```

```{r}
deg_out_cent <- degree(g, v = V(g), mode = "out", loops = TRUE, normalized = TRUE)
deg_out_cent
summary(deg_out_cent)
```

```{r}
plot_dist(deg_out_cent)
```

```{r}
V(g)$deg_out_cent <- deg_out_cent
```

### Normalized Out-Degree Centrality

### K-Core Index

```{r}
in_core <- coreness(g, mode = "in")
in_core
summary(in_core)
```

```{r}
plot_dist(in_core)
```

```{r}
V(g)$in_core <- in_core
```

```{r}
out_core <- coreness(g, mode = "out")
out_core
summary(out_core)
```

```{r}
plot_dist(out_core)
```

```{r}
V(g)$out_core <- out_core
```

### Normalized Betweenness Centrality

```{r}
btw_cent <- betweenness(g, directed = TRUE, normalized = TRUE)
btw_cent
summary(btw_cent)

```

```{r}
plot_dist(btw_cent)
```

```{r}
V(g)$btw_cent <- btw_cent
```

### Normalized In-Closeness Centrality

```{r}
clo_in  <- closeness(g, mode = "in",  normalized = TRUE)
clo_in
summary(clo_in)
```

```{r}
plot_dist(clo_in)
```

```{r}
V(g)$clo_in <- clo_in
```

### Normalized Out-Closeness Centrality

```{r}
clo_out  <- closeness(g, mode = "out",  normalized = TRUE)
clo_out
summary(clo_out)
```

```{r}
plot_dist(clo_out)
```

```{r}
V(g)$clo_out <- clo_out
```

### Eigenvector - Not for directed graphs

### Page Rank

```{r}

pr <- page_rank(g, directed = TRUE)$vector
pr
summary(pr)
```

```{r}
plot_dist(pr)
```

```{r}
V(g)$pagerank <- pr
```

### Bonacich Centrality

```{r}

bon <- power_centrality(g, exponent = 0.1, rescale = TRUE)
bon
summary(bon)

```

```{r}
plot_dist(bon)
```

```{r}
V(g)$bonacich <- bon
```

### Edge Betweenness Centrality

```{r}
ebtw <- edge_betweenness(g, directed = TRUE)
#not printing this one out.  There are 400+ edges here.
# Also, there is no "normalized" version of edge betweenness in igraph
summary(ebtw)
```

```{r}
plot_dist(ebtw)
```

```{r}
E(g)$edge_betweenness <- ebtw
```

### Nearest Neighbor Edge Centrality

```{r}
deg_in  <- degree(g, mode = "in")
deg_out <- degree(g, mode = "out")
deg_tot <- deg_in + deg_out


nne_edge_centrality <- function(g, deg_tot) {
  sapply(E(g), function(e) {
    v <- ends(g, e)
    (deg_tot[v[1]] - 1) + (deg_tot[v[2]] - 1)
  })
}

E(g)$nne <- nne_edge_centrality(g, deg_tot)

```

If we want to store in degree nearest-neighbor edge centrality

```{r}
E(g)$nne_in <- sapply(E(g), function(e) {
  v <- ends(g, e)
  (deg_in[v[1]] - 1) + (deg_in[v[2]] - 1)
})

```

And out degree nearest-neighbor edge centrality

```{r}
E(g)$nne_out <- sapply(E(g), function(e) {
  v <- ends(g, e)
  (deg_out[v[1]] - 1) + (deg_out[v[2]] - 1)
})

```

```{r}
summary(E(g)$nne)
```

```{r}
plot_dist(E(g)$nne)
```

```{r}
summary(E(g)$nne_in)
```

```{r}
plot_dist(E(g)$nne_in)
```

```{r}
summary(E(g)$nne_out)
```

```{r}
plot_dist(E(g)$nne_out)
```

### Local Clustering Coefficient

Recall, this is dependent on triangles, and directed graphs have a lot
of potential definitions for triangles. Instead, let's look at the
measure as if this graph were undirected (this is common).

```{r}

cc_local <- transitivity(as.undirected(g, mode = "collapse"),
                         type = "local", isolates = "zero")
cc_local
summary(cc_local)

```

```{r}
plot_dist(cc_local)
```

```{r}
V(g)$clust_local <- cc_local
```

### Local Efficiency

```{r}
le_in <- local_efficiency(g, directed = TRUE, mode = "in")
le_in
summary(le_in)
```

```{r}
plot_dist(le_in)
```

```{r}
V(g)$local_eff_in <- le_in
```

```{r}
le_out <- local_efficiency(g, directed = TRUE, mode = "out")
le_out
summary(le_out)
```

```{r}
plot_dist(le_out)
```

```{r}
V(g)$local_eff_out <- le_out
```

### Burt's Constraint

```{r}
bc <- constraint(g)
bc
summary(bc)

```

```{r}
plot_dist(bc)
```

```{r}
V(g)$constraint <- bc
```

## 3d.) Roles ----

### Communities (necessary to evaluate roles)

This is a directed graph, so I'm going to use infomap. Technically, you
can use other methods that support directed graphs as well, but
brokerage depends on community membership.

```{r}
comm <- cluster_infomap(g)
V(g)$community <- membership(comm)
sizes(comm)

```

### SNA

We finally have to leave the world of igraph. The library SNA (social
network analysis) has the functions we are looking for

```{r}
library(sna)
```

Notice all the messages? We have overlapping functions. If you want to
use any of these, make sure to precede it by igraph::function() or
sna::function() SNA tends to work with adjacency matrix defined graphs,
so we have to do a little bit more work:

```{r}
A <- as.matrix(as_adjacency_matrix(g, sparse = FALSE))

grp <- V(g)$community
grp2 <- V(g)$shape
```

### Brokerage

```{r}
brok <- brokerage(A, cl = grp)
```

```{r}
summary(brok)
```

LOL. Right. So, now we have something to figure out. WHAT does this all
mean? w_I is a coordinator w_0 is an itinerant broker b_I0 is a
gatekeeper b_0I is a representative b_0 is a liasion t is combined.

The z-scores are calculated as:

$$ z = \frac{\text{observed brokerage} - \text{expected brokerage}}{\text{SD under random null}}$$

So a positive z indicates more brokerage than expected and a negative z
indicates less brokerage than expected.\
But these z scores need to be taken with a grain of salt and compared
against the actual graph visualization. Look for very high scores
relative to other scores.\
For example: V4 has a W_I z score of more than 13. This indicates that
there is pretty strong evidence that V4 is a coordinator.\
LIP seems to have a very high b_I0 score indicating that it may serve as
a gate keeper.\
VIP seems to act as both a representative and a gate keeper in cluster
2.

Now, remember that there were natural groups already identified in this
network? Let's try to use those instead (they are stored in grp2)

```{r}
brok2 <- brokerage(A, cl = grp2)
```

```{r}
summary(brok2)
```

### Prestige

Obviously in-degree is a measure of prestige. The other methods are page
rank, authority scores, and hub scores.

```{r}

auth <- hits_scores(g, scale = TRUE)
auth$hub
auth$authority
```

```{r}
plot_dist(auth$authority)
```

```{r}
plot_dist(auth$hub)
```

```{r}
V(g)$authority <- auth$authority
V(g)$hub <- auth$hub
```

## One last thing.

We've been saving all of these measures as node and edge properties...

```{r}
summary(g)
```

## 4.) Your turn

The dolphins dataset is stored as a .rds object (igraph in r) same as
this dataset was. This is a network from observations of dolphins and is
a pretty fun one to consider for this task. It is unweighted,
undirected, and pretty straight forward for this excersize.

Please walk back through this lab and see what it shows you about node
and edge level measures for this community (or communities) of dolphins.
Identify important dolphins using the measures we have defined. Is it
always the same dolphin? What does this say about their roles within the
pod? How many communities are there and how do members play brokerage
roles in these communities?

## 5.) Results

What you need to do next is to "knit" your document into an html using
the "Knit" button near the top of the screen. This will give you an HTML
that you can turn in.
